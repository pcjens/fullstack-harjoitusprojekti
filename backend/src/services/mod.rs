use sqlx::{AnyPool, Row};

pub mod portfolio;
pub mod user;
pub mod work;

const TABLES_WITH_INTEGER_KEYS: &[&str] =
    &["categories", "portfolios", "users", "work_attachments", "work_links", "work_tags", "works"];

/// Since SQLite and PostgreSQL don't seem to have a way to make good primary
/// keys that would work as desired for both databases, this function exists to
/// make the integer primary keys in the database be `generated by default as
/// identity` if the database driver is PostgreSQL. This makes them work like
/// how SQLite handles a regular old `integer primary key`.
pub async fn patch_postgres_primary_keys(db: &mut AnyPool) {
    let mut conn = db.acquire().await.expect("postgresql database should be reachable");
    let backend_name = conn.backend_name();
    tracing::debug!("Database backend: {}", backend_name);
    if backend_name == "PostgreSQL" {
        tracing::info!("PostgreSQL detected, patching all primary keys.");
        for table in TABLES_WITH_INTEGER_KEYS {
            // Safety: "table" isn't from user input.
            let get_attributes_query = format!(
                "SELECT (attidentity = '') AS no_identity FROM pg_attribute \
                WHERE attnum > 0 AND attrelid = (SELECT oid FROM pg_class WHERE relname = '{table}')"
            );
            let no_identity_query =
                format!("ALTER TABLE {table} ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY");

            match sqlx::query(&get_attributes_query).fetch_one(&mut *conn).await {
                Ok(row) => {
                    let no_identity = row.get::<bool, _>(0);
                    if no_identity {
                        tracing::debug!("Patching table \"{}\".", table);
                        sqlx::query(&no_identity_query)
                            .execute(&mut *conn)
                            .await
                            .expect("should be able to add an identity column for a table which does not have one");
                    } else {
                        tracing::debug!("Table \"{}\" has already been patched.", table);
                    }
                }
                Err(err) => {
                    tracing::warn!("Failed to query postgres attributes for table {}, trying patch primary key anyway ({})", table, err);
                    let _ = sqlx::query(&no_identity_query).execute(&mut *conn).await;
                }
            }
        }
    }
}
